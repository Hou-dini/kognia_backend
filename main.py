import uvicorn
import asyncpg
import uuid
import os

from fastapi import FastAPI, HTTPException, Body, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field
from contextlib import asynccontextmanager

from google.genai import types
from google.adk.runners import Runner
from google.adk.memory import InMemoryMemoryService
from google.adk.sessions import DatabaseSessionService
from google.adk.apps.app import App, EventsCompactionConfig
from google.adk.plugins.logging_plugin import LoggingPlugin

from agents.agent import root_agent



# --- Configuration ---
# CRITICAL: Get your Supabase Postgres connection string
# Go to Supabase -> Project Settings -> Database -> Connection string -> URI
# Paste it into an environment variable or right here (for dev).
# Make sure to replace [YOUR-PASSWORD]
# Example: "postgres://postgres:[YOUR-PASSWORD]@db.xxxxxx.supabase.co:5432/postgres"

DATABASE_URL = os.environ.get("DATABASE_URL")


# This will hold our database connection pool
db_pool = None

# --- Lifespan Management ---
# This function runs on app startup and shutdown
@asynccontextmanager
async def lifespan(app: FastAPI):
    # --- Startup ---
    print("FastAPI app starting up...")
    print("Connecting to Supabase (Postgres)...")
    try:
        global db_pool
        # Create a connection pool
        db_pool = await asyncpg.create_pool(
            DATABASE_URL,
            min_size=1,
            max_size=10
        )
        # Test the connection
        async with db_pool.acquire() as connection: # type: ignore
            test_query = await connection.fetchval("SELECT 1")
            if test_query == 1:
                print("Supabase connection successful!")
            else:
                raise Exception("Failed to verify Supabase connection.")
        print("Database pool created.")
    except Exception as e:
        print(f"FATAL: Could not connect to database: {e}")
        # In a real app, you might want to prevent startup
        # For our sprint, we log and continue, but it will fail on requests.
        db_pool = None # Ensure it's None if setup failed

    print("Initializing ADK Agent Runner and Services...")
    try:
        db_url = "sqlite:///flux.db"
        memory_service = InMemoryMemoryService()
        session_service = DatabaseSessionService(db_url=db_url)
        app_with_compaction = App(
            name="agents",
            root_agent=root_agent,
            events_compaction_config=EventsCompactionConfig(
                compaction_interval=5,
                overlap_size=2,
            )
        )
        runner_instance = Runner(
            app=app_with_compaction,
            agent=root_agent,
            memory_service=memory_service,
            session_service=session_service,
            plugins=[LoggingPlugin()],
        )
        print("ADK Agent Runner initialized.")
        # Attach the runner to the app state for access in endpoints
        app.state.runner = runner_instance
    except Exception as e:
        print(f"FATAL: Could not initialize ADK Agent Runner: {e}")
        app.state.runner = None

    yield # This is where the app runs

    # --- Shutdown ---
    print("FastAPI app shutting down...")
    if db_pool:
        await db_pool.close()
        print("Database pool closed.")

# --- FastAPI App Initialization ---

app = FastAPI(
    title="Flux API (Unified)",
    description="API to manage agentic brand and competitor analysis jobs. Runs agents as background tasks.",
    version="0.2.0",
    lifespan=lifespan # Use our startup/shutdown manager
)

# --- CORS ---
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], # Allow all for our sprint
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- Pydantic Models ---
class JobRequest(BaseModel):
    prompt: str = Field(..., min_length=10, description="The user's prompt for analysis.")
    session_id: str = Field(..., description="UUID generated by the frontend for this chat session.")
    auth_token: str = Field(..., description="Authentication token for user verification.")

class JobStatus(BaseModel):
    job_id: str
    status: str

class ReportResponse(BaseModel):
    job_id: str
    status: str
    report: str | None = None

class SessionSummary(BaseModel):
    id: str
    title: str
    updated_at: str # Use string for datetime in response for simplicity

class MessageResponseItem(BaseModel):
    role: str
    content: str
    timestamp: str # Use string for datetime

# --- Agent Logic (To be run in background) ---

async def run_agent_task(job_id: str, prompt: str, user_id: str, session_id: str):
    """
    Runs the agent for a given job in the background.
    Updates the job status and stores the report in the database.
    """
    print(f"[Job {job_id}]: Starting background agent task...")

    # 1. Retrieve the runner from the global app state
   
    runner = app.state.runner

    if not runner:
        print(f"[Job {job_id}]: FATAL- Runner not initialized.")

        await update_job_status(job_id, "error")
        return
    
    try:
        # 2. Update job status to 'running'
        await update_job_status(job_id, "running")

        print(f"[Job {job_id}]: Creating session: {session_id} for user: {user_id}...")
        try:
            await runner.session_service.create_session(app_name="agents", user_id=user_id, session_id=session_id)
            print(f"[Job {job_id}]: Session created successfully.")
        except Exception as e:
            pass


        # Log user's message to the DB
        async with db_pool.acquire() as conn: # type: ignore
            await conn.execute(
                "INSERT INTO messages (session_id, role, content) VALUES($1, $2, $3)", 
                session_id, "user", prompt
            )

        # 3. Run the agent and get the response
        
        report_content = await get_agent_response(runner, prompt, user_id, session_id)

        if not report_content:
            print(f"[Job {job_id}]: FATAL- No report content received from agent.")
            await update_job_status(job_id, "error")
            return
        
        # Explicit Memory Save after completion for Long-Term Context
        print(f"[Job {job_id}]: Archiving session to Long-Term Memory...")
        try:
            # A. Retrieve the active session object we just used
            session_obj = await runner.session_service.get_session(
                app_name="agents", user_id=user_id, session_id=session_id
            )

            # B. Save to Memory Service (for vector storage or recall)
            if session_obj:
                await runner.memory_service.add_session_to_memory(session_obj)
                print(f"[Job {job_id}]: Session archived successfully.")
            else:
                print(f"[Job {job_id}]: WARNING- Session object not found for archiving.")
        except Exception as mem_e:
            print(f"[Job {job_id}]: WARNING- Failed to save memory: {mem_e}")

        # Log agent's report to the DB
        async with db_pool.acquire() as conn: # type: ignore
            await conn.execute(
                "INSERT INTO messages (session_id, role, content) VALUES($1, $2, $3)",
                session_id, "model", report_content
            )

        # 4. Save Report and Complete Job
        async with db_pool.acquire() as conn: # type: ignore
            await conn.execute(
                "INSERT INTO reports (job_id, content) VALUES($1, $2)", 
                job_id, report_content
            )


            await update_job_status(job_id, "complete")
        print(f"[Job {job_id}]: Success Report Saved.")

    except Exception as e:
        print(f"[Job {job_id}]: FATAL- Error: {e}")
        await update_job_status(job_id, "error")


async def get_agent_response(runner, prompt: str, user_id: str, session_id: str) -> str:
        
    """
    Runs the agent and extracts the final text response for the database.
    """

    # Prepare input for the agent
    user_input = types.Content(
        role="user",
        parts=[types.Part(text=prompt)]
    )


    # Run and iterate through event stream
    final_text = ""
    
    async for event in runner.run_async(
        user_id=user_id,
        session_id=session_id,
        new_message=user_input,
    ):
        # Check if this event is the final answer from the model
        if event.is_final_response and event.content and event.content.parts:
            final_text = event.content.parts[0].text
            print(f"[Agent] Final response received.")

    return final_text

async def update_job_status(job_id: str, status: str):
    """
    Updates the status of a job in the database.
    """

    try:
        async with db_pool.acquire() as conn: # type: ignore
            await conn.execute(
                "UPDATE jobs SET status = $1 WHERE id = $2",
                status,
                uuid.UUID(job_id)
            )
        print(f"[Job {job_id}]: Status updated to '{status}'.")
    except Exception as e:
        print(f"[Job {job_id}]: Error updating status to '{status}': {e}")


async def get_or_create_user(conn, user_id: str):
    """
    Fetches an existing user by id, or creates one if it doesn't exist.
    Returns the user_id (UUID).
    """
    try:
        user_uuid = uuid.UUID(user_id)
    except ValueError:
        # If auth_token is not a valid UUID, generate one deterministically
        # (in production, you'd extract/hash the token properly)
        user_uuid = uuid.uuid5(uuid.NAMESPACE_DNS, str(user_id))

    # Check if user already exists
    existing_user = await conn.fetchval("SELECT id FROM users WHERE id = $1", user_uuid)
    if existing_user:
        return user_uuid

    # User doesn't exist, create one with minimal data
    try:
        # Generate a placeholder email based on the UUID
        placeholder_email = f"user+{user_uuid}@brandspark.local"
        await conn.execute(
            "INSERT INTO users (id, email) VALUES ($1, $2)",
            user_uuid, placeholder_email
        )
        print(f"Created new user: {user_uuid} with email: {placeholder_email}")
    except Exception as e:
        # User might have been created by another request in a race condition
        # Try to fetch again
        existing_user = await conn.fetchval("SELECT id FROM users WHERE id = $1", user_uuid)
        if existing_user:
            return user_uuid
        # If still fails, re-raise
        raise e

    return user_uuid


# --- API Endpoints ---

@app.post("/api/v1/jobs", response_model=JobStatus)
async def create_job(
    background_tasks: BackgroundTasks, # FastAPI injects this
    job_request: JobRequest = Body(...),
    # In a real app, you'd verify auth_token here
    # For our sprint, we skip auth verification
    # user: User = Depends(get_current_user)
):
    """
    Create a new analysis job.
    This runs instantly, creates the job, and schedules the agent
    to run in the background.
    """
    # For now (Dev Mode), we hardcode user_id
    # authenticated_user_id = user.id
    authenticated_user_id = job_request.auth_token
    # Get the session_id from the frontend request
    client_session_id = job_request.session_id
    print(f"Received new job request from {authenticated_user_id} with prompt: {job_request.prompt}")
    
    if db_pool is None:
        raise HTTPException(
            status_code=503, 
            detail="Database connection is not available. Check server logs."
        )

    try:
        # 1. Acquire a connection from the pool
        async with db_pool.acquire() as conn:
            # 1a. Get or create the user
            user_id = await get_or_create_user(conn, authenticated_user_id)
            print(f"Using user_id: {user_id}")

            # 1b. Create session in DB first (if not exists)
            existing_session = await conn.fetchval(
                "SELECT COUNT(1) FROM sessions WHERE id = $1",
                client_session_id
            )
            if existing_session == 0:
                await conn.execute(
                    "INSERT INTO sessions (id, user_id, title) VALUES ($1, $2, $3)",
                    client_session_id, user_id, job_request.prompt[:50]
                )
                print(f"Session {client_session_id} created in DB.")
            
            # 2. Insert the new job into the 'jobs' table
            new_job_id = await conn.fetchval(
                "INSERT INTO jobs (prompt, status, session_id) VALUES ($1, $2, $3) RETURNING id",
                job_request.prompt, 'pending', client_session_id
            )
            
            if not new_job_id:
                raise HTTPException(status_code=500, detail="Failed to create job in database.")

            # 3. Add the REAL agent task to the background queue
            background_tasks.add_task(
                run_agent_task, str(new_job_id), job_request.prompt, 
                authenticated_user_id,
                client_session_id,
                )
            
            print(f"Job {new_job_id} created and background task scheduled.")
            
            # 4. Return the new job ID and 'pending' status immediately
            return JobStatus(job_id=str(new_job_id), status="pending")
    
    except Exception as e:
        print(f"Error creating job: {e}")
        raise HTTPException(status_code=500, detail=f"Internal server error: {e}")


@app.get("/api/v1/jobs/{job_id}", response_model=ReportResponse)
async def get_job_status(job_id: str):
    """
    Get the status of a job.
    The frontend will poll this endpoint.
    """
    print(f"Polling for job ID: {job_id}")
    
    if db_pool is None:
        raise HTTPException(
            status_code=503, 
            detail="Database connection is not available."
        )
        
    try:
        job_uuid = uuid.UUID(job_id) # Validate UUID format
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid job ID format. Must be a UUID.")

    try:
        async with db_pool.acquire() as conn:
            # Check the job status first
            job_record = await conn.fetchrow("SELECT status FROM jobs WHERE id = $1", job_uuid)
            
            if not job_record:
                raise HTTPException(status_code=404, detail="Job not found")

            status = job_record['status']

            if status == "complete":
                # If complete, fetch the report content
                report_content = await conn.fetchval(
                    "SELECT content FROM reports WHERE job_id = $1",
                    job_uuid
                )
                return ReportResponse(job_id=job_id, status="complete", report=report_content)
            
            else:
                # If 'pending', 'running', or 'error', just return the status
                return ReportResponse(job_id=job_id, status=status, report=None)

    except Exception as e:
        print(f"Error fetching job status: {e}")
        raise HTTPException(status_code=500, detail=f"Internal server error: {e}")
    

@app.get("/api/v1/sessions", response_model=list[SessionSummary])
async def get_all_sessions(auth_token: str): # Expect auth_token directly or via Depends if you implement proper auth
    """
    Retrieves all chat sessions for the authenticated user.
    """
    if db_pool is None:
        raise HTTPException(
            status_code=503,
            detail="Database connection is not available."
        )

    try:
        authenticated_user_id = auth_token # As per your current backend logic
        user_uuid = uuid.uuid5(uuid.NAMESPACE_DNS, str(authenticated_user_id)) if not is_valid_uuid(authenticated_user_id) else uuid.UUID(authenticated_user_id)

        async with db_pool.acquire() as conn:
            # Fetch sessions for this user, ordered by most recent update
            sessions = await conn.fetch(
                "SELECT id, title, updated_at FROM sessions WHERE user_id = $1 ORDER BY updated_at DESC",
                user_uuid
            )
            # Format to Pydantic model
            return [
                SessionSummary(
                    id=str(s['id']),
                    title=s['title'],
                    updated_at=s['updated_at'].isoformat() # Convert datetime to ISO string
                ) for s in sessions
            ]
    except Exception as e:
        print(f"Error fetching all sessions: {e}")
        raise HTTPException(status_code=500, detail=f"Internal server error: {e}")
    
# Helper to check if a string is a valid UUID
def is_valid_uuid(uuid_to_test, version=4):
    try:
        uuid_obj = uuid.UUID(uuid_to_test, version=version)
    except ValueError:
        return False
    return str(uuid_obj) == uuid_to_test
    
@app.get("/api/v1/sessions/{session_id}/messages", response_model=list[MessageResponseItem])
async def get_session_messages(session_id: str, auth_token: str): # Expect auth_token for user verification
    """
    Retrieves all messages for a specific chat session, verifying user ownership.
    """
    if db_pool is None:
        raise HTTPException(
            status_code=503,
            detail="Database connection is not available."
        )

    try:
        session_uuid = uuid.UUID(session_id)
        authenticated_user_id = auth_token
        user_uuid = uuid.uuid5(uuid.NAMESPACE_DNS, str(authenticated_user_id)) if not is_valid_uuid(authenticated_user_id) else uuid.UUID(authenticated_user_id)

        async with db_pool.acquire() as conn:
            # First, verify that the session belongs to the authenticated user
            session_owner_id = await conn.fetchval(
                "SELECT user_id FROM sessions WHERE id = $1",
                session_uuid
            )
            if not session_owner_id or session_owner_id != user_uuid:
                raise HTTPException(status_code=403, detail="Forbidden: You do not own this session or it does not exist.")

            # If authorized, fetch messages
            messages = await conn.fetch(
                "SELECT role, content, timestamp FROM messages WHERE session_id = $1 ORDER BY timestamp ASC",
                session_uuid
            )
            return [
                MessageResponseItem(
                    role=m['role'],
                    content=m['content'],
                    timestamp=m['timestamp'].isoformat() # Convert datetime to ISO string
                ) for m in messages
            ]
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid session ID format. Must be a UUID.")
    except Exception as e:
        print(f"Error fetching messages for session {session_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Internal server error: {e}")


# --- Main Entry Point ---
if __name__ == "__main__":
    # Note: Uvicorn's 'reload=True' is great for dev but can be tricky
    # with lifespan events. For production, run with gunicorn or similar.
    print("Starting Uvicorn server in reload mode...")
    
    uvicorn.run("main:app", host="127.0.0.1", port=8000, reload=True)